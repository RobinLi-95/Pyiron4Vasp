# This is the Script for Regulate the VASP Calculation Input files [INCAR] [KPOINTS]
# The General Calculation like: Single-Point Energy Calculation; Geometry Optimisation Calculation for Bulk and Slab; Cell Optimisation for Determining Relaxed Lattice Parameters; Nudeged-Elastic Band Calculations;
# To be Continued ...
# Author: Bingxin Li
# Date: 09/08/2024
# Contact: b.li@mpie.de

import numpy as np
import copy as cp
from pyiron.project import Project

class VaspInput():
    """
    Class for inputing essential parameters for VASP Calculations

    Attributes:

    """

    def __init__(self,proj,basis,name,jobtype,cell_sys='bulk/pri_slab'):
        '''
        @proj:input the Pyiron project 
        @basis:input the structure generated by the Pyiron modules
        @name:input the name for the submitting job
        @jobtype:which type of calculation is: single-point energy calculation ("single_point"); geometry optimisation ("geo_opt"); cell relaxation ("vc_relax"); nudged-elastic band calculation
        @cell_sys:system is a bulk or slab
        '''

        self.proj = proj
        self.basis =cp.deepcopy(basis)
        self.name = name
        self.jobtype = jobtype # At present job type could be single_point, geo_opt, vc_relax
        self.cell_sys = cell_sys

        return
    
    # Define a function to create a Pyiron-Vasp job
    def JobCreator(self,pyironjob):
        # IDK why they use ham but guess this represents hamiltonian 
        # Here we set-up a VASP-based calculation
        self.ham = self.proj.create_job(pyironjob.job_type.Vasp, self.name, delete_existing_job=True)
        self.ham.structure = self.basis

        return(self.ham)
 
    #  Define a function to set-up the general input parameters for Vasp calcualtion
    def JobGeneral(self,wave_function='F',charge_density='F',local_pot='T',elf='.FALSE.',dos=False,sym_precision=1e-8, gga_compact='.FALSE.'):
        self.ham.input.incar['LWAVE'] = wave_function # Write wavefunctions
        self.ham.input.incar['LCHARG'] = charge_density # Write charge densities
        self.ham.input.incar['LVHAR'] = local_pot # Write the local potential, which contains hartree, ionic and xc
        self.ham.input.incar['LELF'] = elf # Write the electron localisation distribution
        self.ham.input.incar['SYMPREC'] = sym_precision # Determine to which accuracy the positions in the POSCAR 
        if dos != False:
            self.ham.input.incar['LORBIT'] = dos # Wether to print DOSCAR/PROCAR/PROOUT

        return(self.ham)

    #  Define a function to set-up the electronic relaxation parameters for Vasp calcualtion
    def EleRelaxPara(self,elec_step_max=200,elec_step_min=3,elec_precision=1e-7,ener_cutoff=500, vdW=False):
        self.vdW = vdW
        self.ham.input.incar['NELM'] = elec_step_max # Max number for electronic optimisation 
        self.ham.input.incar['NELMIN'] = elec_step_min # Minimum number for electronic optimisation
        self.ham.input.incar['EDIFF'] = elec_precision # Convergence criteria for electronic step
        self.ham.input.incar['ENCUT'] = ener_cutoff # Energy Cutoff for the Calculation
        self.ham.input.incar['PREC'] = 'A' # Precision preset
        self.ham.input.incar['ALGO'] = 'N' # Normal Algorithm
        self.ham.input.incar['IDIAG'] = 'T' # Sub-space diagonalisation
        self.ham.input.incar['LREAL'] = 'F' # Automatic for real-space projection
        if self.vdW == True:
            self.ham.input.incar['IVDW'] = 11 # Consider dispersion correction: using DFT-D3 method for Grimme with Zero-damping function

        return(self.ham)

    #  Define a function to set-up the ionic (including geo-opt and cell-relax) relaxation parameters for Vasp calcualtion
    def IonRelaxPara(self,ionic_step=50,step_width=0.5,force_correction=True):
        self.ham.input.incar['NSW'] = ionic_step # Number of ionic step
        self.ham.input.incar['POTIM'] = step_width # Step-width in ionic relaxation
        self.ham.input.incar['LCORR'] = force_correction # Harris correction to forces

        if self.jobtype == 'single_point':
            self.ham.input.incar['NSW'] = 0
            self.ham.input.incar['IBRION'] = -1 # No update for ion's position
        elif self.jobtype == 'geo_opt':
            self.ham.input.incar['IBRION'] = 2 # Ionic Relax: 0-MD, 1-Quasi-Newton, 2-CG
            self.ham.input.incar['ISIF'] = 2
        elif self.jobtype == 'vc_relax':
            self.ham.input.incar['IBRION'] = 2
            self.ham.input.incar['ISIF'] = 3
        
        return(self.ham)

    #  Define a function to set-up the dipole-correction for the asymmetric slab calculations
    def DipoleCorr(self,dipole_axis=3):
        
        center_cell = [0., 0., (np.min(self.basis.get_scaled_positions()[:, 2]) +
              np.max(self.basis.get_scaled_positions()[:, 2])) / 2.]

        self.center_cell = " ".join([str(c) for c in center_cell])

        if self.cell_sys == 'slab_ad':
            self.ham.input.incar['LDIPOL'] = ".TRUE."
            self.ham.input.incar['IDIPOL'] = dipole_axis # Which axis the dipole correction is on
            self.ham.input.incar['DIPOL'] = self.center_cell # Center of mass of the atoms(slabs) in the unit cell
        
        return(self.ham)

    #  Define a function to set-up the smearing parameters for Vasp calcualtion
    def Smearing(self,smear_method=0,sigma=0.1):
        self.ham.input.incar['ISMEAR'] = smear_method # Smearing method: Gaussian method
        self.ham.input.incar['SIGMA'] = sigma # Smearing Parameters

        return(self.ham)

    #  Define a function to set-up the K-Points for Vasp calcualtion
    def KpoinsSetting(self,mesh=[2,2,2]):
        if mesh == "GP":
            # Only the Gamma point
            self.ham.set_kpoints(scheme="GP")
        elif len(mesh) == 3:
            self.ham.set_kpoints(mesh=mesh)

        return(self.ham)

    #  Define a function to set-up the pseudopotentials/functionals used for Vasp calcualtion
    def Functionals(self,functional='PBE'):
        self.ham.input.potcar["xc"] = functional

        return(self.ham)

    #  Define a function to set-up the vasp_version for Vasp calcualtion
    def ChooseVASP_Version(self,version='5.4.4_mpi'):
        self.ham.executable.version = version

        return(self.ham)










